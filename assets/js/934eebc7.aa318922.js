"use strict";(self.webpackChunkmesodocs=self.webpackChunkmesodocs||[]).push([[8299],{4137:(e,t,n)=>{n.d(t,{Zo:()=>p,kt:()=>h});var a=n(7294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function l(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?l(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):l(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function o(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},l=Object.keys(e);for(a=0;a<l.length;a++)n=l[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var l=Object.getOwnPropertySymbols(e);for(a=0;a<l.length;a++)n=l[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var s=a.createContext({}),u=function(e){var t=a.useContext(s),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},p=function(e){var t=u(e.components);return a.createElement(s.Provider,{value:t},e.children)},c="mdxType",m={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},d=a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,l=e.originalType,s=e.parentName,p=o(e,["components","mdxType","originalType","parentName"]),c=u(n),d=r,h=c["".concat(s,".").concat(d)]||c[d]||m[d]||l;return n?a.createElement(h,i(i({ref:t},p),{},{components:n})):a.createElement(h,i({ref:t},p))}));function h(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var l=n.length,i=new Array(l);i[0]=d;var o={};for(var s in t)hasOwnProperty.call(t,s)&&(o[s]=t[s]);o.originalType=e,o[c]="string"==typeof e?e:r,i[1]=o;for(var u=2;u<l;u++)i[u]=n[u];return a.createElement.apply(null,i)}return a.createElement.apply(null,n)}d.displayName="MDXCreateElement"},9208:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>s,contentTitle:()=>i,default:()=>m,frontMatter:()=>l,metadata:()=>o,toc:()=>u});var a=n(7462),r=(n(7294),n(4137));const l={},i="Ray Tune",o={unversionedId:"arch_exp/turpan/ressources_ia/ray_tune",id:"arch_exp/turpan/ressources_ia/ray_tune",title:"Ray Tune",description:"Ray Tune is a scalable framework for hyperparameter optimization that makes it easy to run many training experiments in parallel. Each experiment, called a trial, trains a model using a different combination of hyperparameters such as the learning rate, batch size, number of layers, or optimizer settings. Instead of manually launching dozens of experiments one by one, Ray Tune automates this process and distributes the work across all available computational resources.",source:"@site/docs/arch_exp/turpan/ressources_ia/ray_tune.md",sourceDirName:"arch_exp/turpan/ressources_ia",slug:"/arch_exp/turpan/ressources_ia/ray_tune",permalink:"/documentation/user-documentation/arch_exp/turpan/ressources_ia/ray_tune",draft:!1,tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Flow Matching",permalink:"/documentation/user-documentation/arch_exp/turpan/ressources_ia/flow_matching"},next:{title:"Lancer un calcul",permalink:"/documentation/user-documentation/arch_exp/turpan/soumettre_calcul/"}},s={},u=[{value:"Resources on This Page",id:"resources-on-this-page",level:2},{value:"Copying the Example Code",id:"copying-the-example-code",level:2},{value:"Directory Structure",id:"directory-structure",level:2},{value:"File descriptions",id:"file-descriptions",level:3},{value:"SLURM Job Script (sbatch)",id:"slurm-job-script-sbatch",level:2},{value:"Key Concepts",id:"key-concepts",level:3},{value:"Ray Tune Main Script",id:"ray-tune-main-script",level:2},{value:"Initialize Ray in SLURM",id:"initialize-ray-in-slurm",level:3},{value:"Resource Assignment",id:"resource-assignment",level:3},{value:"Ray Tune Search Space (modifiable)",id:"ray-tune-search-space-modifiable",level:2},{value:"How Ray collects results:",id:"how-ray-collects-results",level:3},{value:"Dynamic MNIST Model",id:"dynamic-mnist-model",level:2},{value:"How to Modify the Model for LLM Experiments",id:"how-to-modify-the-model-for-llm-experiments",level:2},{value:"Running the Job",id:"running-the-job",level:2},{value:"Expected Scaling",id:"expected-scaling",level:2},{value:"Using Advanced Search Algorithms (BOHB, HEBO, Optuna, BayesOpt)",id:"using-advanced-search-algorithms-bohb-hebo-optuna-bayesopt",level:2},{value:"Example: Adding a search algorithm",id:"example-adding-a-search-algorithm",level:3}],p={toc:u},c="wrapper";function m(e){let{components:t,...n}=e;return(0,r.kt)(c,(0,a.Z)({},p,n,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"ray-tune"},"Ray Tune"),(0,r.kt)("p",null,"Ray Tune is a scalable framework for hyperparameter optimization that makes it easy to run many training experiments in parallel. Each experiment, called a trial, trains a model using a different combination of hyperparameters such as the learning rate, batch size, number of layers, or optimizer settings. Instead of manually launching dozens of experiments one by one, Ray Tune automates this process and distributes the work across all available computational resources. "),(0,r.kt)("p",null,"One of the strengths of Ray Tune is its support for a wide range of modern optimization algorithms. Beyond simple random search or grid search, it can automatically adapt the sampling of hyperparameters using methods such as BOHB, HEBO, Optuna, Bayesian Optimization, HyperBand, or ASHA. These algorithms learn from the results of previous trials and focus the search on the most promising regions, allowing the model to converge to better hyperparameters with fewer total experiments.  "),(0,r.kt)("p",null,"This document explains how to run Ray Tune on the Turpan cluster using SLURM scripts for two and eight GPUs. It also describes how to modify the hyperparameter configuration, how to switch between search algorithms, and how the training script dynamically builds the neural-network architecture based on the hyperparameters selected for each trial. Finally, it explains how to adapt the example to a models, such as transformer-based LLMs."),(0,r.kt)("hr",null),(0,r.kt)("h2",{id:"resources-on-this-page"},"Resources on This Page"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"#copying-the-example-code"},"Copying the Example Code"),"  "),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"#directory-structure"},"Directory Structure"),"  "),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"#slurm-job-script-sbatch"},"SLURM Job Script"),"  "),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"#ray-tune-main-script"},"Ray Tune Main Script"),"  "),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"#ray-tune-search-space-modifiable"},"Ray Tune Search Space"),"  "),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"#dynamic-mnist-model"},"Dynamic MNIST Model"),"  "),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"#how-to-modify-the-model-for-llm-experiments"},"Modifying for LLM Experiments"),"  "),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"#running-the-job"},"Running the Job"),"  "),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"#expected-scaling"},"Expected Scaling"),"  "),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("a",{parentName:"li",href:"#using-advanced-search-algorithms-bohb-hebo-optuna-bayesopt"},"Advanced Search Algorithms"),"  ")),(0,r.kt)("hr",null),(0,r.kt)("h2",{id:"copying-the-example-code"},"Copying the Example Code"),(0,r.kt)("p",null,"All the example Ray Tune scripts and SLURM launchers are available on Turpan and can be copied directly from:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-bash"},"/work/shares/IA-Tests/ray_tune.tar.gz\n")),(0,r.kt)("p",null,"To extract it in your directory:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-bash"},"tar xvf /work/shares/IA-Tests/ray_tune.tar.gz\n")),(0,r.kt)("p",null,"This will create a directory called ",(0,r.kt)("inlineCode",{parentName:"p"},"ray_tune/")),(0,r.kt)("h2",{id:"directory-structure"},"Directory Structure"),(0,r.kt)("p",null,"After extracting, you will see:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-bash"},"ray_tune/\n\u251c\u2500\u2500 code_and_slurm-scripts\n\u2502   \u251c\u2500\u2500 mnist_ddp.py\n\u2502   \u251c\u2500\u2500 ray_tune.py\n\u2502   \u251c\u2500\u2500 run-ray_tune_on_2gpus_Turpan.sh\n\u2502   \u251c\u2500\u2500 run-ray_tune_on_8gpus_Turpan.sh\n\u251c\u2500\u2500 data\n\u2502   \u2514\u2500\u2500 MNIST/               (downloaded MNIST dataset)\n\u2514\u2500\u2500 README.txt\n")),(0,r.kt)("h3",{id:"file-descriptions"},"File descriptions"),(0,r.kt)("table",null,(0,r.kt)("thead",{parentName:"table"},(0,r.kt)("tr",{parentName:"thead"},(0,r.kt)("th",{parentName:"tr",align:null},"File"),(0,r.kt)("th",{parentName:"tr",align:null},"Description"))),(0,r.kt)("tbody",{parentName:"table"},(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"mnist_ddp.py")),(0,r.kt)("td",{parentName:"tr",align:null},"Training script using PyTorch")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"ray_tune.py")),(0,r.kt)("td",{parentName:"tr",align:null},"Ray Tune hyperparameter tuning script")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"run-ray_tune_on_2gpus_Turpan.sh")),(0,r.kt)("td",{parentName:"tr",align:null},"SLURM script to run Ray Tune on 2 GPUs.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"run-ray_tune_on_8gpus_Turpan.sh")),(0,r.kt)("td",{parentName:"tr",align:null},"SLURM script to run Ray Tune on 8 GPUs.")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"data/MNIST")),(0,r.kt)("td",{parentName:"tr",align:null},"MNIST dataset (downloaded automatically if missing).")),(0,r.kt)("tr",{parentName:"tbody"},(0,r.kt)("td",{parentName:"tr",align:null},(0,r.kt)("inlineCode",{parentName:"td"},"README.txt")),(0,r.kt)("td",{parentName:"tr",align:null},"Instructions and notes.")))),(0,r.kt)("p",null,"The file to be changed to add your trainning is mnist_ddp.py"),(0,r.kt)("h2",{id:"slurm-job-script-sbatch"},"SLURM Job Script (sbatch)"),(0,r.kt)("p",null,"Below is the job file used to launch Ray Tune on ",(0,r.kt)("strong",{parentName:"p"},"4 nodes"),", each with ",(0,r.kt)("strong",{parentName:"p"},"2 GPUs"),", using ",(0,r.kt)("inlineCode",{parentName:"p"},"srun")," + ",(0,r.kt)("inlineCode",{parentName:"p"},"apptainer"),"."),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-bash"},"#!/bin/bash\n#SBATCH --job-name=benchmark\n#SBATCH -N 4\n#SBATCH --ntasks=4\n#SBATCH --cpus-per-task=40\n#SBATCH --mem=100G\n#SBATCH --time=40\n#SBATCH --gres=gpu:2\n\nsrun apptainer exec --bind /tmpdir,/work --nv /work/conteneurs/sessions-interactives/pytorch-24.02-py3-calmip-si.sif python3 ray_tune.py\n")),(0,r.kt)("h3",{id:"key-concepts"},"Key Concepts"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("strong",{parentName:"li"},"1 Ray trial = 1 process launched by Ray"),"  "),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"--ntasks=4")," = ",(0,r.kt)("inlineCode",{parentName:"li"},"-N 4")," \u21d2 4 Ray workers  "),(0,r.kt)("li",{parentName:"ul"},"Each worker sees ",(0,r.kt)("strong",{parentName:"li"},"2 GPUs")," because of ",(0,r.kt)("inlineCode",{parentName:"li"},"--gres=gpu:2"),"  "),(0,r.kt)("li",{parentName:"ul"},"Ray automatically detects all the GPUs in the reservation via ",(0,r.kt)("inlineCode",{parentName:"li"},"ray.cluster_resources()"),"  "),(0,r.kt)("li",{parentName:"ul"},"Trials run ",(0,r.kt)("strong",{parentName:"li"},"in parallel")," as long as there are free GPUs")),(0,r.kt)("hr",null),(0,r.kt)("h2",{id:"ray-tune-main-script"},"Ray Tune Main Script"),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"ray_tune.py")," launches Ray, defines the search space, scheduler, and submits trials."),(0,r.kt)("p",null,"Key parts:"),(0,r.kt)("h3",{id:"initialize-ray-in-slurm"},"Initialize Ray in SLURM"),(0,r.kt)("p",null,"Ray is launched locally inside the job:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-python"},'ray.init(\n    num_cpus=max(1, int(os.environ.get("SLURM_CPUS_PER_TASK", "40"))),\n    include_dashboard=False,\n    _system_config={"enable_metrics_collection": False}\n)\n')),(0,r.kt)("h3",{id:"resource-assignment"},"Resource Assignment"),(0,r.kt)("p",null,"Each trial uses:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-python"},'tune.with_resources(original_main, resources={"cpu": 4, "gpu": 1})\n')),(0,r.kt)("p",null,"This means:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Each trial uses ",(0,r.kt)("strong",{parentName:"li"},"1 GPU")),(0,r.kt)("li",{parentName:"ul"},"The cluster nodes have 2 GPUs \u2192 ",(0,r.kt)("strong",{parentName:"li"},"2 parallel trials per node")),(0,r.kt)("li",{parentName:"ul"},"With 4 nodes \u2192 ",(0,r.kt)("strong",{parentName:"li"},"8 parallel trials total"))),(0,r.kt)("p",null,"GPUs per trial can be changed but at that time trainning the code needs to use ",(0,r.kt)("inlineCode",{parentName:"p"},"DistributedDataParallel")," or other method to perform data parallelism:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-python"},'resources={"gpu": 2}\n')),(0,r.kt)("hr",null),(0,r.kt)("h2",{id:"ray-tune-search-space-modifiable"},"Ray Tune Search Space (modifiable)"),(0,r.kt)("p",null,"Example used in your test:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-python"},'config = {\n    "lr": tune.loguniform(1e-5, 5e-3),\n    "batch_size": tune.choice([16, 32, 64, 128]),\n    "optimizer": tune.choice(["adam", "sgd", "adamw"]),\n    "weight_decay": tune.uniform(0.0, 0.1),\n\n    "conv1_channels": tune.choice([8, 16, 32, 64]),\n    "conv2_channels": tune.choice([16, 32, 64, 128]),\n    "conv3_channels": tune.choice([0, 16, 32, 64, 128]),\n\n    "kernel1": tune.choice([3, 5, 7]),\n    "kernel2": tune.choice([3, 5, 7]),\n    "kernel3": tune.choice([3, 5, 7]),\n\n    "activation": tune.choice(["relu", "gelu", "silu"]),\n    "dropout": tune.uniform(0.0, 0.5),\n\n    "fc_dim": tune.choice([64, 128, 256, 512]),\n\n    "scheduler": tune.choice(["none", "cosine", "step", "onecycle"]),\n    "step_size": tune.choice([10, 20, 30]),\n    "gamma": tune.uniform(0.1, 0.9),\n\n    "epochs": tune.choice([2, 3, 5]),\n    "num_classes": 10,\n}\n')),(0,r.kt)("p",null,"\ud83d\udca1 Modify these values to expand or reduce the search space."),(0,r.kt)("hr",null),(0,r.kt)("h3",{id:"how-ray-collects-results"},"How Ray collects results:"),(0,r.kt)("p",null,"Each epoch:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-python"},'tune.report({"loss": loss_sum / len(train_loader)})\n')),(0,r.kt)("p",null,"To check the output:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-python"},"cat slurm-<JOBID>.out\n")),(0,r.kt)("hr",null),(0,r.kt)("h2",{id:"dynamic-mnist-model"},"Dynamic MNIST Model"),(0,r.kt)("p",null,"Inside ",(0,r.kt)("inlineCode",{parentName:"p"},"mnist_ddp.py"),", the model is built dynamically from the configuration."),(0,r.kt)("p",null,"Example:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-python"},'self.layer1 = nn.Sequential(\n    nn.Conv2d(1, config["conv1_channels"], config["kernel1"], padding=config["kernel1"]//2),\n    nn.BatchNorm2d(config["conv1_channels"]),\n    nn.ReLU(),\n    nn.MaxPool2d(2)\n)\n')),(0,r.kt)("p",null,"This allows:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"adding/removing layers  "),(0,r.kt)("li",{parentName:"ul"},"testing different widths  "),(0,r.kt)("li",{parentName:"ul"},"changing activations  "),(0,r.kt)("li",{parentName:"ul"},"using dropout  "),(0,r.kt)("li",{parentName:"ul"},"changing kernel sizes  ")),(0,r.kt)("p",null,"Everything is done ",(0,r.kt)("strong",{parentName:"p"},"automatically per-trial"),"."),(0,r.kt)("hr",null),(0,r.kt)("h2",{id:"how-to-modify-the-model-for-llm-experiments"},"How to Modify the Model for LLM Experiments"),(0,r.kt)("p",null,"If you switch from MNIST \u2192 T5 (5B model), just replace the model code:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-python"},'from transformers import T5Config, T5ForConditionalGeneration\n\nconfig_llm = T5Config(\n    d_model=config["hidden_size"],\n    num_heads=config["num_heads"],\n    num_layers=config["num_layers"]\n)\n\nmodel = T5ForConditionalGeneration(config_llm)\n')),(0,r.kt)("p",null,"Define hyperparameters in the Ray config, example:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-python"},'"hidden_size": tune.choice([512, 768, 1024]),\n"num_heads": tune.choice([8, 12, 16]),\n"num_layers": tune.choice([4, 8, 12]),\n')),(0,r.kt)("p",null,"And remove MNIST parts."),(0,r.kt)("hr",null),(0,r.kt)("h2",{id:"running-the-job"},"Running the Job"),(0,r.kt)("p",null,"Submit example for 2 GPUs:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-bash"},"sbatch run-ray_tune_on_2gpus_Turpan.sh\n")),(0,r.kt)("p",null,"Submit example for 8 GPUs:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-bash"},"sbatch run-ray_tune_on_8gpus_Turpan.sh\n")),(0,r.kt)("p",null,"To check that the code is running:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-bash"},"squeue --me\n")),(0,r.kt)("p",null,"To check that the GPUs are being used (it is a screen shot of the resources):"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-bash"},"placement --checkme\n")),(0,r.kt)("hr",null),(0,r.kt)("h2",{id:"expected-scaling"},"Expected Scaling"),(0,r.kt)("p",null,"If you keep:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},'resources={"gpu": 1}\nnum_samples=8\n')),(0,r.kt)("p",null,"Then:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"1 node = 2 GPUs = 2 parallel trials"),(0,r.kt)("li",{parentName:"ul"},"4 nodes = 8 GPUs = 8 parallel trials \u2192 all trials run simultaneously  "),(0,r.kt)("li",{parentName:"ul"},"Runtime \u2248 equal to training time of ",(0,r.kt)("strong",{parentName:"li"},"one")," model")),(0,r.kt)("p",null,"If you set:"),(0,r.kt)("p",null,(0,r.kt)("inlineCode",{parentName:"p"},"num_samples")," should be equal or greater than the number of GPUs."),(0,r.kt)("hr",null),(0,r.kt)("h2",{id:"using-advanced-search-algorithms-bohb-hebo-optuna-bayesopt"},"Using Advanced Search Algorithms (BOHB, HEBO, Optuna, BayesOpt)"),(0,r.kt)("p",null,"Ray Tune allows you to replace the default random search with more advanced hyperparameter optimization (HPO) algorithms that adaptively select new trials based on previous results."),(0,r.kt)("p",null,"These algorithms are enabled by adding a search algorithm to tune.Tuner() via the argument search_alg=."),(0,r.kt)("h3",{id:"example-adding-a-search-algorithm"},"Example: Adding a search algorithm"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre"},'from ray import tune\nfrom ray.tune.search.bohb import TuneBOHB\nfrom ray.tune.search.optuna import OptunaSearch\nfrom ray.tune.search.hebo import HEBOSearch\nfrom ray.tune.search.bayesopt import BayesOptSearch\n\nsearch_alg = OptunaSearch()  # <-- select one algo here\n\ntuner = tune.Tuner(\n    train_fn,\n    param_space=config,\n    tune_config=tune.TuneConfig(\n        metric="loss",\n        mode="min",\n        num_samples=50,        # how many trials total\n        search_alg=search_alg, # <-- your optimizer\n        max_concurrent_trials=8,  # how many trials run in parallel (e.g., number of GPUs)\n    ),\n)\ntuner.fit()\n')),(0,r.kt)("hr",null))}m.isMDXComponent=!0}}]);